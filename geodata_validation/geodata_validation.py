# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ValidateGeodata
                                 A QGIS plugin
 Vaildate geodata in repect to geometry, coordinate reference system and data structure
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-02-16
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Jo Ritter
        email                : tempmail@mail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis import processing
from qgis.core import Qgis

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .geodata_validation_dialog import ValidateGeodataDialog
from .funcs import GeometryChecks, DataStructureChecks, CrsChecks
from .funcs import status

import os.path

# ONLY DURING DEVELOPEMENT!!!!!!
import traceback


class ValidateGeodata:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ValidateGeodata_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Geodata Validation')

        self.validated = False
        self.results = [] # list of Result objects
        self.results = {} # change to results list of results objects (make result class that can be analysed standardised)
        self.infotext = status.Infotext("")

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ValidateGeodata', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def __clicked_export__(self):
        self.infotext.append("Clicked Export functionality... not implemented yet")

        if self.validated:
            if self.dlg.OutputFilePath.filePath() != '':
                self.infotext.append(f" Output path: {self.dlg.OutputFilePath.filePath()}")
            else:
                self.infotext.add_error("Missing output file!")
        else:
            self.infotext.add_warning("Need to validate geodata beforehand")
        self.dlg.OutputTextArea.setPlainText(self.infotext.content)
    
    def __clicked_cancel__(self):
        # need to clean up infos first because states are stored (like text editor box, set crs, ...)
        self.infotext.clear()
        self.dlg.OutputTextArea.setPlainText(self.infotext.content)
        #self.dlg.checkBoxGeometry.setChecked(True)
        #self.dlg.checkBoxDataStructure.setChecked(True)
        #self.dlg.checkBoxCrs.setChecked(True)
        self.dlg.close()
    
    def __validate_geodata__(self):
        # clear all previous validaton results first
        self.infotext.clear()
        self.results.clear()

        input_file = self.dlg.InputFilePath.filePath()
        self.infotext.add_info(f"input filepath: {input_file}")

        map_layer = self.dlg.SelectMapLayer.currentLayer()
        self.infotext.add_info(f"selected_project_layer: {map_layer}")

        input_layer = map_layer or input_file
        self.infotext.add_info(f"input_layer: {input_layer}")
        
        # totally forgot about other geometry types. Have to deal with points and lines too

        
        # geometryy checks
        if self.dlg.checkBoxGeometryValidity.isChecked():
            
            #TOTALLY STILL TO DO IN GENERALL
            self.infotext.add_info("Checking validity of geometry!")
            
            try:
                checkvalidity = processing.run("qgis:checkvalidity", {
                    'INPUT_LAYER':'D:\\Jo\\PythonProjekte\\QGIS\\testdata\\nogeometry.shp',
                    'METHOD':1,
                    'IGNORE_RING_SELF_INTERSECTION':False,
                    'VALID_OUTPUT':'TEMPORARY_OUTPUT',
                    'INVALID_OUTPUT':'TEMPORARY_OUTPUT',
                    'ERROR_OUTPUT':'TEMPORARY_OUTPUT'})
                
                self.infotext.add_info("...")

                check_valid_result = status.Result('check_validity')

                for k in checkvalidity.keys():
                    if 'OUTPUT' in k: 
                        checkvalidity[k].setName('CheckValid_' + k)
                

                
                if checkvalidity['ERROR_COUNT'] > 0: 
                    self.infotext.add_warning(f"{checkvalidity['ERROR_COUNT']} errors found!")
                if checkvalidity['INVALID_COUNT'] > 0:
                    self.infotext.add_warning(f"{checkvalidity['INVALID_COUNT']} invalid gemetries found!")

            except:
                self.infotext.add_error("Running qgis algorithm check validity failed")
        

        if self.dlg.checkBoxGeoHoles.isChecked():
            try:
                (result, info) = GeometryChecks.holes(input_layer)
            except Exception:
                self.infotext.add_error(f"Checking for Holes in Geometries and layer failed!")
                self.infotext.append(f"{traceback.format_exc()}")


        if self.dlg.checkBoxGeoEmpty.isChecked():
            pass


        if self.dlg.checkBoxGeoOverlaps.isChecked():
            pass

        
        # data structure checks
        if self.dlg.checkBoxDSIntegrity.isChecked():
            # Problem bei mehrmaliger Durchführung nach schließen mit cancel --> siehe diese Funktion!!!!!
            self.infotext.add_info("Checking the data structure!")
            self.infotext.add_info("Checking if attributes or objects with mostly NULL values exist...")
            try:
                (null_geodata, null_info) = DataStructureChecks.null_vals(vectorlayer=input_layer)
                if null_info:
                    self.infotext.append(null_info.content)
                if null_geodata:
                    # DEAL WITH RESULTINGGEODATA IF THERE ARE SOME
                    pass

            except Exception as e:
                self.infotext.add_error(f"Failed to test for null values")
                self.infotext.append(f"{traceback.format_exc()}")
        
        if self.dlg.checkBoxDSDuplicates.isChecked():
            pass
        

        # crs checks
        if self.dlg.checkBoxCrs.isChecked():
            self.infotext.add_info("checking and characterizing the crs")

            crs =self.dlg.CrsSelector.crs()
            if crs.isValid():
                self.infotext.add_info("Valid Crs selected")
                self.infotext.add_info(f"Crs: {crs}")
            else:
                self.infotext.add_warning("no Crs chosen")
        
        if self.dlg.checkBoxCrsBounds.isChecked():
            pass
        
        self.dlg.OutputTextArea.setPlainText(self.infotext.content)

        self.validated = True

        # run all the different validaton algorithms
        # 1) check for validity (processing.run("qgis:checkvalidity"))
        # 2) check for empty geometries
        # 2b) check for overlaps
        # 2c) check for holes
        # 3) check if shp-file is valid (n_shp = n_dbf = n_shx)
        # 4) check crs - if it is categorized with a code, what kind of crs it is (compound, ...)
        # 5) check crs against a selected one
        # 6) check data, if there is a column that meets the requirement of an oid
        # 7) check for duplicates

        # check if geometries are 3D and whether this fits the crs
        # either via geometry type or QgsAbstractGeometry
        # check crs postgissrid, type and vertical component 

        # from osgeo import ogr
        # gpkg_path = r"D:\Jo\PythonProjekte\QGIS\testdata\polygon_wgs84.gpkg"
        # layers = [l.GetName() for l in ogr.Open(gpkg_path)]

        # out = processing.run("qgis:checkvalidity", {'INPUT_LAYER':'D:\\Jo\\PythonProjekte\\QGIS\\testdata\\nogeometry.shp','METHOD':1,'IGNORE_RING_SELF_INTERSECTION':False,'VALID_OUTPUT':'TEMPORARY_OUTPUT','INVALID_OUTPUT':'TEMPORARY_OUTPUT','ERROR_OUTPUT':'TEMPORARY_OUTPUT'})
        # out = dict and it will contain all 3 layers and all 3 values


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/geodata_validation/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Validate Geodata'),
            callback=self.run,
            parent=self.iface.mainWindow())
        
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Geodata Validation'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = ValidateGeodataDialog()

            self.dlg.ButtonOk.clicked.connect(self.__clicked_export__)
            
            self.dlg.ButtonValidate.clicked.connect(self.__validate_geodata__)
            
            self.dlg.ButtonCancel.clicked.connect(self.__clicked_cancel__)
            
            self.dlg.CrsSelector.setMessage("Optional - can be used to check Crs against this selection")
            #self.dlg.CrsSelector.setNotSetText("Optional - can be used to check Crs against this selection")
            #self.dlg.CrsSelector.setOptionVisible(1, False)
            
            self.dlg.OutputFilePath.setFilter("Text (*.txt)")

            self.dlg.SelectMapLayer.setAllowEmptyLayer(allowEmpty=True, text='no project layer')
            self.dlg.SelectMapLayer.setFilters(Qgis.LayerFilter.VectorLayer)
        
        
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        running = self.dlg.exec_()


    